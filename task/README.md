# Задание

В данном задании мы предлагаем вам попробовать реализовать ансамбли из 2-3х моделей для семантической сегментации класса "машина" и сравнить их качество на подвыборке из датасета cityscapes (датасет приложен к заданию).

Эта задача довольно популярна в ML, но, для полноты картины, мы хотим привести несколько примеров, где это может пригодиться в реальных условиях:
- в задачах реконструкции сцены часто требуется исключить динамические объекты (людей, машины)
- при обучении модели на новых данных мы используем предобученные модели для автоматической разметки, чтобы ускорить работу HITL
- некоторые алгоритмы полностью обучаются на предразмеченных данных

## Что нужно сделать
- Нужно найти 2-3 любых предобученных модели семантической сегментации, которые можно использовать для сегментации класса "машина"
- Используя предоставленный датасет, нужно посчитать качество этих моделей по отдельности
- Затем нужно агрегировать их предсказания в различных сочитаениях и посчитать качество
- Результатом задачи будет сравнение качества работы ансамблей и отдельных моделей на датасете cityscapes.

> Важно: ансамбль не всегда дает лучшее качество. Целью задания является сравнение качества и поиск лучшего метода использования предобученных моделей, а не улучшение качества за счет ансамбля.

# Датасет

Датасет представляет из себя подвыборку датасета [cityscapes leftImg8bit_trainvaltest.zip](https://www.cityscapes-dataset.com/downloads/). Мы оставили только избражения, содержащие машины (id=26), удалив при этом все остальные классы из GT.

## Структура

```
dataset
├── imgs -> Исходные изображения (640х640)
│ ├── 000000.png
│ ├── 000001.png
│   ...
├── gt_sem_seg -> Маска для класса "машина" (640х640)
│ ├── 000000.png
│ ├── 000001.png
│   ...
```

## Пример использования

```python
import os

import cv2
from matplotlib import pyplot as plt

imgs_dir = "./dataset/imgs"
sem_seg_dir = "./dataset/gt_sem_seg"

def get_img_and_gt(index):
    img = cv2.imread(os.path.join(imgs_dir, f"{index:06d}.png"))
    sem_seg = cv2.imread(os.path.join(sem_seg_dir, f"{index:06d}.png"), cv2.IMREAD_GRAYSCALE)
    return img, sem_seg

img_index = 900
img, sem_seg = get_img_and_gt(img_index)

plt.figure()
_ = plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
plt.figure()
_ = plt.imshow(sem_seg)
```

# Оценка задания

Оцениваться будет правильность кода и его структура.

Также, на обсуждении задания будут затронуты следующие вопросы:
- почему именно эти модели?
- почему вы агрегировали их именно этим методом?
- почему вы выбрали эти метрики для сравнения качества?
